/*
 * EffecTV for Android
 * Copyright (C) 2013 Morihiro Soft
 *
 * Utils.h: utilities
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

/*
 * EffecTV - Realtime Digital Video Effector
 * Copyright (C) 2001-2006 FUKUCHI Kentaro
 *
 * utils.h: header file for utils
 * image.c: utilities for image processing.
 * yuv.c: YUV(YCbCr) color system utilities
 *
 */

#ifndef __UTILS__
#define __UTILS__

//---------------------------------------------------------------------
// Common types
//---------------------------------------------------------------------
typedef unsigned int RGB32;
#define PIXEL_SIZE (sizeof(RGB32))

typedef unsigned char YUV;

//---------------------------------------------------------------------
// Macros
//---------------------------------------------------------------------
/* DEFINE's by nullset@dookie.net */
#define RED(n)       ((n>>16) & 0x000000FF)
#define GREEN(n)     ((n>> 8) & 0x000000FF)
#define BLUE(n)      ((n>> 0) & 0x000000FF)
#define RGB(r,g,b)   ((r<<16) + (g<<8) + (b))
#define INTENSITY(n) (((RED(n)+GREEN(n)+BLUE(n))/3))

//---------------------------------------------------------------------
// Utilities
//---------------------------------------------------------------------
class Utils {
	//-----------------------------------------------------------------
	// UTILS
	//-----------------------------------------------------------------
public:
	Utils(int width, int height);
	~Utils();

	void HSItoRGB(double H, double S, double I, int *r, int *g, int *b);

	/*
	 * fastrand - fast fake random number generator
	 * Warning: The low-order bits of numbers generated by fastrand()
	 *          are bad as random numbers. For example, fastrand()%4
	 *          generates 1,2,3,0,1,2,3,0...
	 *          You should use high-order bits.
	 */
	void fastsrand(unsigned int);
	inline unsigned int fastrand() {return (fastrand_val=fastrand_val*1103515245+12345);}

private:
	int video_width;
	int video_height;
	int video_area;

	unsigned int fastrand_val;

	//-----------------------------------------------------------------
	// IMAGE
	//-----------------------------------------------------------------
public:
	RGB32* stretching_buffer;

	int image_init(int width, int height);
	int image_end(void);
	void image_stretching_buffer_clear(RGB32 color);
	void image_stretch(RGB32* src, int src_width, int src_height, RGB32* dst, int dst_width, int dst_height);
#if 0
	void image_stretch_to_screen(void);
#endif

	void image_set_threshold_y(int threshold);
	void image_bgset_y(RGB32* src);
	void image_bgget_y(RGB32* dst);
	unsigned char* image_bgsubtract_y(RGB32* src);
	unsigned char* image_bgsubtract_update_y(RGB32* src);
	unsigned char* image_y_over(RGB32* src);
	unsigned char* image_y_under(RGB32* src);

	void image_set_threshold_yuv_y(int threshold);
	void image_bgset_yuv_y(YUV* src);
	unsigned char* image_bgsubtract_yuv_y(YUV* src);
	unsigned char* image_bgsubtract_update_yuv_y(YUV* src);
	unsigned char* image_yuv_y_over(YUV* src);
	unsigned char* image_yuv_y_under(YUV* src);

	void image_set_threshold_RGB(int r, int g, int b);
	void image_bgset_RGB(RGB32* src);
	unsigned char* image_bgsubtract_RGB(RGB32* src);
	unsigned char* image_bgsubtract_update_RGB(RGB32* src);

	unsigned char* image_diff_filter(unsigned char* diff);
	unsigned char* image_edge(RGB32* src);
	void image_hflip(RGB32* src, RGB32* dst, int width, int height);

private:
	RGB32* background;
	unsigned char* diff;
	unsigned char* diff2;
	int y_threshold;
	RGB32 rgb_threshold;

#if 0
	void image_stretch_to_screen_double(void);
#endif

	//-----------------------------------------------------------------
	// YUV
	//-----------------------------------------------------------------
public:
	int YtoRGB[256];
	int VtoR[256], VtoG[256];
	int UtoG[256], UtoB[256];
	int RtoY[256], RtoU[256], RtoV[256];
	int GtoY[256], GtoU[256], GtoV[256];
	int BtoY[256],            BtoV[256];

	RGB32* tmp_rgb32;
	YUV* tmp_yuv;

	int yuv_init(void);
	int yuv_end(void);
	unsigned char yuv_RGBtoY(int rgb);
	unsigned char yuv_RGBtoU(int rgb);
	unsigned char yuv_RGBtoV(int rgb);
	RGB32* yuv_YUVtoRGB(YUV* yuv, RGB32* rgb32=NULL);
	YUV* yuv_RGBtoYUV(RGB32* rgb32, int yuv_fmt=0, YUV* yuv=NULL);

private:
	RGB32 yuv_YUVtoRGB_1(int y, int u, int v);
	YUV* yuv_RGBtoNV12(RGB32* rgb32, YUV* yuv);
	YUV* yuv_RGBtoNV21(RGB32* rgb32, YUV* yuv);
	YUV* yuv_RGBtoI420(RGB32* rgb32, YUV* yuv);
};

#endif // __UTILS__
